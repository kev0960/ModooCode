----------------
title : 씹어먹는 C ++ - <예외 처리>>
next_page : 6
path : /C/C Lectures
cat_title : C 언어가 뭐야?
updated_date : 09/12/2018
published : false
--------------

안녕하세요 여러분! 오래 간만에 인사 드립니다. 이번 강좌에서는 C++ 에서 예외 처리를 어떠한 방식으로 하는지에 대해 알아보도록 하겠습니다.

### 예외란?

우리가 이상적인 세상에서 살고 있다면, 그 어떤 예외적인 상황도 없을 것입니다. 프로그램 혹은 라이브러리 사용자들은 언제나 올바른 값을 입력값으로 줄 것이고, 컴퓨터 역시 무한한 자원을 사용할 수 있어서 어떠한 상황에서도 데이터들을 정상적으로 처리할 수 있을 것입니다.

하지만, 안타깝게도 이 세상은 그리 녹록하지 않습니다. 사람들은 실수를 하기 마련이고, 컴퓨터 역시 언제나 프로그램에 필요한 자원을 제공할 수 있는 것이 아닙니다. 예를 들어서 아래와 같은 `vector` 의 사용 예시를 살펴봅시다.

```cpp
  std::vector<int> v(3); // 크기가 3 인 벡터 만듦
  std::cout << v.at(4); // ?? 
```

위 경우, 크기가 3 인 `vector` 를 만들었지만 4 번째 원소를 요청하고 있습니다. 위와 같은 코드는 문법 상 아무 문제가 없는 코드이지만, 막상 실행하게 되면 오류가 발생하게 됩니다.

다른 예로 아래와 같이 큰 메모리를 할당하는 경우를 생각해봅시다.

```cpp
  std::vector<int> v(1000000000);
  // ?
```

여러분이 사용하는 대부분의 시스템의 경우 위와 같이 큰 메모리를 할당할 수 없습니다. 따라서, 위 코드 역시 문법 상 틀린 것이 없는 코드 이지만, 실제로 실행해보면 오류가 발생하게 됩니다. 

이렇게 정상적인 상황에서 벗어난 모든 예외적인 상황들을 **예외(exception)** 이라고 부릅니다. 

### 기존의 예외 처리 방식

C 언어에서는 언어 차원에서 제공하는 예외 처리 방식이라는 것이 딱히 따로 존재하지 않았습니다. 따라서 아래와 같이, 어떤 작업을 실행한 뒤에 그 결과값을 확인하는 방식으로 처리하였습니다. 예를 들어서 아래 `malloc` 으로 메모리를 동적으로 할당하는 경우를 생각해봅시다.

```cpp
  char *c = (char *)malloc(1000000000);
  if (c == NULL) {
    printf("메모리 할당 오류!");
    return;
  }
```

`malloc` 의 경우 메모리 할당 실패시에 `NULL` 을 리턴하므로, 위와 같이 `c` 가 `NULL` 인지 확인함으로써 예외적인 상황을 처리할 수 있었습니다.

하지만 이러한 방식으로 예외를 처리한다면, 함수가 깊어지면 깊어질 수 록 꽤나 귀찮게 됩니다. 예를 들어서 아래와 같은 예시를 살펴보세요.

```cpp
bool func1(int *addr) { 
  if (func2(addr)) {
    // Do something
  }
  return false;
}
bool func2(int *addr) { 
  if (func3(addr)) {
    // Do something
  }
  return false;
}
bool func3(int *addr) { 
  addr = (int *)malloc(100000000);
  if (addr == NULL) return false;
  return true;
}
int main() {
  int* addr;
  if (func1(addr)) {
    // 잘 처리됨
  } else {
    // 오류 발생
  }
}
```

위 코드의 경우 func3 에서 '예외가 발생할 수 있는 작업' 을 수행하는데, 만약에 예외가 발생하게 된다면 false 를 리턴하게 되고, 잘 처리 되었다면 true 를 리턴합니다. 

여기까지는 좋은데, 문제는 이 func3 가 func2 에서 호출되고, 다시 func2 는 func1 에서 호출되고, func1 은 main 에서 호출된다는 점입니다. 만약에 main 의 입장에서 func3 에서 문제가 발생했을 때 이를 캐치하기 위해서는, 각각의 함수들에서 처리 결과를 모두 리턴해야 할 것입니다.

위 코드는 예외가 func3 에서만 발생해서 간단하였지만, 만약에 func2 도 어떤 다른 작업을 해서 예외를 발생시킬 수 있다면 어떻게 해야 할까요? 상당히 골치 아픈 일입니다.

하지만 다행이도 C++ 에서는 위와 같은 불편한 예외 처리 방식을 획기적으로 해결시켰습니다.

### 예외 발생시키기 - throw

C 언어에서는 예외가 발생했을 때, 다른 값을 리턴하는 것으로 예외를 처리하였지만, C++ 에서는 예외가 발생하였다는 사실을 명시적으로 나타낼 수 있습니다. 바로 throw 문을 사용해서 말입니다.

예를 들어서 아래와 같이 매우 간단한 vector 클래스를 생각해봅시다.

```cpp
template <typename T>
class Vector {
  public:
    Vector(size_t size) {
      data = new T[size];
    }
    const T& at(size_t index) {
      if (index >= size) {
        throw range_error("Index out of range!");
      }
      return data[index];
    }

  private:
  T* data;
  size_t size;
};
```
